## Бинарный поиск в массиве
https://leetcode.com/problems/binary-search
### Решение
Классический алгоритм бинарного поиска. Опорный элемент берется как середина отрезка. 
Далее левая/правая граница отрезка смещается от опорного элемента на 1 единицу внутрь отрезка 
(опорный элемент уже проверен, нет смысла снова включать его в отрезок). Всё это до тех пор, пока не нашли целевое значение 
(или пока отрезок не превратился в пустой - тогда нет решения)

```java
    public int search(int[] nums, int target) {
        int a = 0, b = nums.length - 1, m;
        while (a <= b) {
            m = (a + b) / 2;
            if (nums[m] == target) {
                return m;
            }
            else if (nums[m] > target) {
                b = m - 1;
            }
            else  {
                a = m + 1;
            }

        }
        
        return -1;
    }
```
