## Search in sorted array
https://leetcode.com/problems/binary-search
### Решение
Классический алгоритм бинарного поиска. Опорный элемент берется как середина отрезка. 
Далее левая/правая граница отрезка смещается от опорного элемента на 1 единицу внутрь отрезка 
(опорный элемент уже проверен, нет смысла снова включать его в отрезок). Всё это до тех пор, пока не нашли целевое значение 
(или пока отрезок не превратился в пустой - тогда нет решения)

```java
    public int search(int[] nums, int target) {
        int a = 0, b = nums.length - 1, m;
        while (a <= b) {
            m = (a + b) / 2;
            if (nums[m] == target) {
                return m;
            }
            else if (nums[m] > target) {
                b = m - 1;
            }
            else  {
                a = m + 1;
            }

        }
        
        return -1;
    }
```

## Search in rotated sorted array
https://leetcode.com/problems/search-in-rotated-sorted-array

Дан массив, который получен из отсортированного путем поворота вокруг какой-то точки.

Например, 1 2 3 4 5 6 => 3 4 5 6 1 2

Найти в этом массиве значение `target`.

### Решение
Модифицированный бинарный поиск.

Заметим, что если взять в массиве любую точку, то относительно этой точки либо левая часть массива будет отсортированной, либо правая.

Алгоритм следующий:

0. Разделить массив на 2 равные части
1. Понять, какая часть отсортированная
2. Проверить, лежит ли целевое значение внутри этой части (проверить можно по крайним точкам, ведь часть отсортирована!)
3. Если целевое значение лежит в этой части, то продолжить в ней поиск. Если нет - продолжить поиск в оставшемся массиве.
4. Если интервал поиска стал пустым, а значение не найдено - значит его нет, вернуть -1

```java
class Solution {
     public int search(int[] nums, int target) {
        int start = 0;
        int end = nums.length - 1;
          
        while (start <= end){
            int mid = (start + end) / 2;
            if (nums[mid] == target)
                return mid;
        
            if (nums[start] <= nums[mid]) {
                 if (target < nums[mid] && target >= nums[start]) 
                    end = mid - 1;
                 else
                    start = mid + 1;
            } 
            else {
                if (target > nums[mid] && target <= nums[end])
                    start = mid + 1;
                 else
                    end = mid - 1;
            }
        }
        return -1;
    }
}
```

## Find minimum in rotated sorted array

https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/

### Решение

Заметим, что минимумом в этом массиве является как раз именно та точка, по которой массив повернули. Хотя бывает, что массив и не поворачивали, так что ответом может быть и nums[0]

Найдем точку поворота (`pivot`) бинарным поиском.

```java
    public int findMin(int[] nums) {
        int start = 0;
        int end = nums.length - 1;
        
        int pivot = -1;
        
        while (start <= end) {
            
            pivot = (start + end) / 2;
            
            if (nums[0] <= nums[pivot]) { //массив от 0 до pivot отсортирован => не подходит нам
                start = pivot + 1;
            } 
            else {
                // массив от 0 до pivot не отсортирован, значит pivot внутри него.
                if (nums[pivot-1] > nums[pivot]) // может быть так, что pivot уже найден, и дальше нет смысла искать
                    return nums[pivot];
                end = pivot - 1;
            }
        }
      
        // если дошли до этой строчки кода, то значит pivot не был найден
        return nums[0];
    }
```
## Find K closest elements in a sorted array
https://leetcode.com/problems/find-k-closest-elements/
Есть отсортированный массив `arr`, число `k`, число `x`. Надо из этого массива вернуть `k` чисел, ближайших к `x`.

### Решение
Пусть массив длины n. Очевидно, что задача сводится к поиску ближайшего к числу `x` элемента по индексам [0..n-k-1], 
поскольку нужно вернуть k подряд идущих элементов. При этом, если таких элементов несколько (они повторяются), 
нужно найти тот, который имеет в массиве наименьший индекс.

Для этого в бинарном поиске будем смотреть отрезок [mid..mid+k]

Теперь найдем, в какой границе отрезка находится значение, более близкое к `x`. Исходя из этого можно удалить из рассмотрения область до `mid`, либо область после `mid`. Таким образом, после некоторого числа итераций, будет найдено значение, наиболее близкое к `x`.

(!) Важно, что в проверке расстояния до числа `x` стоит знак "меньше". В случае, когда
`Math.abs(x - arr[mid]) == Math.abs(x - arr[mid+k])`, предпочтение отдается элементам с наименьшим индексом. Например, если
смотрим отрезок [1 1 2 2 3 3 3], а надо найти 2 числа, ближайшие к двойке, то поиск будем продолжать в отрезке [1 1 2], а не [3 3 3]

UPD: решение неверное, несмотря на то, что его принимает сайт.
Контрпример: [1,1,1,2,3,3,3,3], ищем одно число, ближайшее к 2. На выходе 1. 
Надо найти другое решение.

```java
class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        int start = 0, end = arr.length - 1 - k, mid;
        
        while (start <= end) {
            mid = (start + end) / 2;
            if (Math.abs(x - arr[mid]) > Math.abs(x - arr[mid+k])) { // (mid+k)-ый элемент ближе к x, чем (mid)-ый
                start = mid + 1; // ищем в (mid..end]
            }
            else {
                end = mid - 1; // ищем в [start..mid)
            }
        }
        
        List<Integer> res = new ArrayList(k);
        for (int i = 0; i < k; ++i) {
            res.add(arr[start + i]);
        }
        
        return res;
    }
}
```
