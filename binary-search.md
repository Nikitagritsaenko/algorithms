## Search in sorted array
https://leetcode.com/problems/binary-search
### Решение
Классический алгоритм бинарного поиска. Опорный элемент берется как середина отрезка. 
Далее левая/правая граница отрезка смещается от опорного элемента на 1 единицу внутрь отрезка 
(опорный элемент уже проверен, нет смысла снова включать его в отрезок). Всё это до тех пор, пока не нашли целевое значение 
(или пока отрезок не превратился в пустой - тогда нет решения)

```java
    public int search(int[] nums, int target) {
        int a = 0, b = nums.length - 1, m;
        while (a <= b) {
            m = (a + b) / 2;
            if (nums[m] == target) {
                return m;
            }
            else if (nums[m] > target) {
                b = m - 1;
            }
            else  {
                a = m + 1;
            }

        }
        
        return -1;
    }
```

## Search in rotated sorted array
Дан массив, который получен из отсортированного путем поворота вокруг какой-то точки.

Например, 1 2 3 4 5 6 => 3 4 5 6 1 2

Найти в этом массиве значение `target`.

### Решение
Модифицированный бинарный поиск.

Заметим, что если взять в массиве любую точку, то относительно этой точки либо левая часть массива будет отсортированной, либо правая.

Алгоритм следующий:

0. Разделить массив на 2 равные части
1. Понять, какая часть отсортированная
2. Проверить, лежит ли целевое значение внутри этой части (проверить можно по крайним точкам, ведь часть отсортирована!)
3. Если целевое значение лежит в этой части, то продолжить в ней поиск. Если нет - продолжить поиск в оставшемся массиве.
4. Если интервал поиска стал пустым, а значение не найдено - значит его нет, вернуть -1

```java
class Solution {
     public int search(int[] nums, int target) {
        int start = 0;
        int end = nums.length - 1;
          
        while (start <= end){
            int mid = (start + end) / 2;
            if (nums[mid] == target)
                return mid;
        
            if (nums[start] <= nums[mid]) {
                 if (target < nums[mid] && target >= nums[start]) 
                    end = mid - 1;
                 else
                    start = mid + 1;
            } 
            else if (nums[mid] <= nums[end]) {
                if (target > nums[mid] && target <= nums[end])
                    start = mid + 1;
                 else
                    end = mid - 1;
            }
        }
        return -1;
    }
}
```
